# 前端进击笔记

王贝珊（被删） 腾讯高级前端工程师 拉钩课程

# 导读 1 | 前端基础知识体系之专业知识篇

需要去关注的几个面试题，需要梳理大纲

- 手写代码实现 Promise
- 为什么要使用 async、await
- 手写代码实现 call/apply/bind。
- JavaScript 中 0.1+0.2 为什么等于 0.30000000000000004，如何通过代码解决这个问题？
- 怎样让 ES6/ES7 代码可以跑在各个浏览器中（考察 Babel 与 polyfill）；
- 介绍下 Set 和 Map 数据结构；
- Javascript 是怎么实现 let 和 const 作用域的。

# 导读 2 | 前端基础知识体系之项目经验篇

前端常见的框架和工具库；
Node.js 和服务端；
前端性能优化；
前端工程化；
前端监控搭建；
开发效率提升。
在前端领域，性能问题常常同样表现为空间和时间两种，顾名思义：
空间性能问题可同样理解为内存占用、CPU 占用、本地缓存占用过多带来的问题（如卡顿）；
时间性能问题则意味着用户等待时间过长，包括页面加载、渲染、可交互等耗时。
首屏性能提速，涉及技术方案可能包括按需加载/懒加载/预加载、秒看、SSR 直出、客户端容器化、客户端离线化等；
网络请求优化，涉及技术方案可能包括 CDN 优化、缓存优化、使用 HTTP/2、资源压缩（Gzip）、请求优化（合并请求、域名拆分、减少 DNS 查询时间）等。

# 01 | 重识 HTML，掌握页面基本结构和加载过程

使用事件委托，可以通过将事件添加到它们的父节点，而将事件委托给父节点来触发处理函数：

绑定子元素会绑定很多次的事件，而绑定父元素只需要一次绑定。
将事件委托给父节点，这样我们对子元素的增加和删除、移动等，都不需要重新进行事件绑定。

# 02 | CSS：页面布局的基本规则和方式

一些问题

## 一个元素总宽高为 50px，要怎么在调整边框大小的时候，不需要重新计算和设置 width/height 呢？

使用 box-sizing 属性可以解决问题 1（调整元素的边框时，不影响元素的宽高），我们可以将元素的 box-sizing 属性设置为 border-box

## 为什么给一些元素设置宽高，但是却不生效？

因为该元素为内联元素，解决办法为设置 display 为 block，inline-block

## 如何将一个元素固定在页面的某个位置，具体怎么做？

将一个元素固定在页面的某个位置，可以通过给元素或是其父类元素添加 position: fixed 或者 position: absolute 将其固定在浏览器窗口或是文档页面中。

## 为什么将某个元素 z-index 设置为 9999999，但是它依然被其他元素遮挡住了呢？

因为除了同级元素以外，z-index 值的设置效果还会受到父元素的 z-index 值的影响。z-index 值的设置只决定同一父元素中的同级子元素的堆叠顺序。因此，即使将某个元素 z-index 设置为 9999999，它依然可能因为父元素的 z-index 值小于其他父元素同级的元素，而导致该元素依然被其他元素遮挡。

## 为什么将某个元素里面的元素设置为 float 之后，这个元素的高度就歪了呢？

## 让一个元素进行垂直和水平居中，有多少种实现方式？

# 03 | JavaScript 如何实现继承？

## JavaScript 的函数怎么也是个对象？

> 在 JavaScript 中，函数也是一种特殊的对象，它同样拥有属性和值。
> `所有的函数会有一个特别的属性prototype`，该属性的值是一个对象，
> 这个对象便是我们常说的“原型对象”。

## `__proto__`和 prototype 到底是啥关系？

> 在 JavaScript 中，`__proto__`属性指向对象的原型对象；
> 对于函数来说，每个函数都有一个 prototype 属性，该属性为该函数的原型对象。

## JavaScript 中对象是怎么实现继承的？

> 1.每个对象都有`__proto__`属性来标识自己所继承的原型对象，但只有函数才有 prototype 属性  
> 2.对于函数来说，每个函数都有一个 prototype 属性，该属性为该函数的原型对象；  
> 3.通过将实例对象的`__proto__`属性赋值为其构造函数的原型对象 prototype
> JavaScript 可以使用构造函数创建对象的方式，来实现继承。

## JavaScript 是怎么访问对象的方法和属性的？

> 1. 首先会优先在该对象上搜寻。如果找不到，还会依次层层向上搜索该对象的原型对象、该对象的原型对象的原型对象等（套娃告警）;
> 2. JavaScript 中的所有对象都来自 Object，`Object.prototype.__proto__ === null`。null 没有原型，并作为这个原型链中的最后一个环节；
> 3. JavaScript 会遍历访问对象的整个原型链，如果最终依然找不到，此时会认为该对象的属性值为 undefined。

**缺点**

- 当试图访问不存在的属性时，会遍历整个原型链；
- 在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。

## JavaScript 中实现继承的方式？

> 1. 原型链继承方式中引用类型的属性被所有实例共享，无法做到实例私有；
> 2. 经典继承方式可以实现实例属性私有，但要求类型只能通过构造函数来定义；
> 3. 组合继承融合原型链继承和构造函数的优点，它的实现如下：

```js
function Parent(name) {
  // 私有属性，不共享
  this.name = name;
}
// 需要复用、共享的方法定义在父类原型上
Parent.prototype.speak = function () {
  console.log("hello");
};
function Child(name) {
  Parent.call(this, name);
}
// 继承方法
Child.prototype = new Parent();
```

## JavaScript 的函数和对象是怎样的关系？

> 函数是对象的一种，函数拥有一个 prototype 的属性用于继承

## `__proto__`和 prototype 都表示原型对象，它们有什么区别呢？

> 只有函数才有 prototype 属性，只有对象才有`__proto__`属性
> prototype 有两个属性 constructor 指向构造函数，`__proto__`指向构造函数的 prototype，

## JavaScript 中对象的继承和原型链是什么关系？

> JavaScript 是通过原型链来实现继承的
> 可以将 proto 比作链，prototype 比作节点，以 null 为顶点链接起来形成原型链，当访问标识符时，
> 实例没有则会去原型链上查找，找到则返回结果，直到顶端 null 没找到则返回 undefined。
